/**************************************************************************************
            ___  _   _______ _                     _     _       ______              _ 
           / _ \| | | | ___ \ |                   (_)   | |      |  ___|            (_)
          / /_\ \ | | | |_/ / | ____ _ _ __   ___  _  __| |______| |_ __ _ _ __ ___  _ 
          |  _  | | | |    /| |/ / _` | '_ \ / _ \| |/ _` |______|  _/ _` | '_ ` _ \| |
          | | | \ \_/ / |\ \|   < (_| | | | | (_) | | (_| |      | || (_| | | | | | | |
          \_| |_/\___/\_| \_|_|\_\__,_|_| |_|\___/|_|\__,_|      \_| \__,_|_| |_| |_|_|
                                                                                       
          DIY Arkanoid "Vaus" paddle clone for Famicom and compatibles
          based on Digispark ATtiny85 development board
          KKusz 2024 https://kusz.me https://github.com/kkusz/avrkanoid-fami

          Original work by Danjovic 2020
          https://github.com/Danjovic/MSX/blob/master/DigiArka

**************************************************************************************/

#include <avr/sleep.h>
#include <avr/interrupt.h>
#include <avr/power.h>
#include <avr/pgmspace.h>

// Lookup table for non-linearity compensation of "linear" potentiometer
const uint16_t Knob_Map[1024] PROGMEM = {
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
    312, 312, 312, 312, 312, 312, 312, 312, 313, 314, 315, 317, 318, 319, 320, 321, 322, 323, 324,
    325, 326, 327, 328, 329, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 344, 345,
    346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 358, 359, 360, 361, 362, 363, 364, 365,
    366, 367, 368, 369, 370, 372, 375, 379, 384, 388, 393, 397, 402, 407, 411, 416, 422, 430, 437,
    445, 452, 460, 467, 475, 482, 490, 497, 504, 511, 518, 524, 531, 538, 545, 552, 559, 566, 573,
    579, 586, 593, 600, 607, 614, 621, 627, 634, 641, 647, 652, 658, 663, 668, 674, 679, 684, 690,
    695, 700, 706, 711, 716, 722, 727, 732, 738, 743, 748, 754, 759, 764, 770, 775, 780, 786, 791,
    796, 802, 807, 812, 817, 823, 826, 827, 829, 830, 831, 833, 834, 835, 837, 838, 839, 841, 842,
    843, 845, 846, 847, 849, 850, 851, 853, 854, 855, 856, 858, 859, 860, 862, 863, 864, 866, 867,
    868, 870, 871, 872, 874, 875, 876, 878, 879, 880, 882, 883, 884, 886, 887, 888, 890, 891, 892,
    894, 895, 896, 898, 899, 900, 902, 903, 904, 906, 907, 908, 910, 911, 912, 914, 915, 916, 916,
    917, 917, 918, 918, 918, 919, 919, 920, 920, 921, 921, 921, 922, 922, 923, 923, 923, 924, 924,
    925, 925, 926, 926, 926, 927, 927, 928, 928, 928, 929, 929, 930, 930, 931, 931, 931, 932, 932,
    933, 933, 933, 934, 934, 935, 935, 936, 936, 936, 937, 937, 938, 938, 939, 939, 939, 940, 940,
    941, 941, 941, 942, 942, 943, 943, 944, 944, 944, 945, 945, 946, 946, 946, 947, 947, 948, 948,
    949, 949, 949, 950, 950, 951, 951, 951, 952, 952, 953, 953, 954, 954, 954, 955, 955, 955, 956,
    956, 956, 956, 957, 957, 957, 957, 957, 958, 958, 958, 958, 959, 959, 959, 959, 959, 960, 960,
    960, 960, 961, 961, 961, 961, 962, 962, 962, 962, 962, 963, 963, 963, 963, 964, 964, 964, 964,
    965, 965, 965, 965, 965, 966, 966, 966, 966, 967, 967, 967, 967, 968, 968, 968, 968, 968, 969,
    969, 969, 969, 970, 970, 970, 970, 971, 971, 971, 971, 971, 972, 972, 972, 972, 973, 973, 973,
    973, 973, 974, 974, 974, 974, 975, 975, 975, 975, 976, 976, 976, 976, 976, 977, 977, 977, 977,
    977, 977, 977, 978, 978, 978, 978, 978, 978, 978, 979, 979, 979, 979, 979, 979, 979, 980, 980,
    980, 980, 980, 980, 980, 981, 981, 981, 981, 981, 981, 982, 982, 982, 982, 982, 982, 982, 983,
    983, 983, 983, 983, 983, 983, 984, 984, 984, 984, 984, 984, 984, 985, 985, 985, 985, 985, 985,
    985, 986, 986, 986, 986, 986, 986, 986, 987, 987, 987, 987, 987, 987, 988, 988, 988, 988, 988,
    988, 988, 989, 989, 989, 989, 989, 989, 989, 990, 990, 990, 990, 990, 990, 990, 991, 991, 991,
    991, 991, 991, 991, 992, 992, 992, 992, 992, 992, 992, 993, 993, 993, 993, 993, 993, 994, 994,
    994, 994, 994, 994, 994, 995, 995, 995, 995, 995, 995, 995, 996, 996, 996, 996, 996, 996, 996,
    997, 997, 997, 997, 997, 997, 997, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999,
    999, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1002,
    1002, 1002, 1002, 1002, 1002, 1002, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1004, 1004, 1004,
    1004, 1004, 1004, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1006, 1006, 1006, 1006, 1006, 1006,
    1006, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1008, 1008, 1008, 1008, 1008, 1008,
    1008, 1008, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1010, 1010, 1010, 1010, 1010, 1010,
    1010, 1010, 1010, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1012, 1012, 1012, 1012, 1012,
    1012, 1012, 1012, 1012, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1014, 1014, 1014, 1014,
    1014, 1014, 1014, 1014, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1016, 1016, 1016, 1016,
    1016, 1016, 1017, 1017, 1017, 1017, 1017, 1018, 1018, 1018, 1018, 1018, 1018, 1019, 1019, 1019,
    1019, 1019, 1019, 1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1021,
    1021, 1021, 1021, 1022, 1022, 2022, 1023, 1023, 1023
};

// output serial knob data
#define DIGI_OUT_P0 0

// input start ADC
#define DIGI_IN_P1  1

// input read knob data
#define DIGI_IN_P2  2

#define MSBIT 8

// uncomment to use LUT for linearity compensation
// #define USE_LUT

volatile uint8_t Input_ADC;
volatile uint16_t Knob_Raw_Input;
volatile uint16_t Shift_Register;
volatile uint8_t Timer_Count = 0;

void setup() {
  init_adc();
  timer_setup();

  cli();

  GIMSK |= (1 << INT0) |
           (1 << PCIE);
  MCUCR =  (0 << ISC00) | // External INT on Falling edge ISC=[10])
           (1 << ISC01); // on pin TRGA (clock)
  PCMSK = (0 << PCINT0) | //
          (1 << PCINT1) | // Pin change INT on PULSE pin
          (0 << PCINT2) | //
          (0 << PCINT3) | //
          (0 << PCINT4) | //
          (0 << PCINT5); //

  // clear any pending interrupts
  GIFR =  (1 << INTF0) |
          (1 << PCIF );

  analogReference(DEFAULT);
  pinMode(DIGI_IN_P1,  INPUT_PULLUP);
  pinMode(DIGI_IN_P2,  INPUT_PULLUP);
  pinMode(DIGI_OUT_P0, OUTPUT);

  sei();
}

void init_adc() {

  ADMUX  = (1 << MUX0 ) | // Select AN3 ADMUX=[0011]
           (1 << MUX1 ) | //
           (0 << MUX2 ) | //
           (0 << MUX3 ) | //
           (0 << REFS2) | //
           (0 << ADLAR) | // Right Aligned value 
           (0 << REFS0) | //
           (0 << REFS1);  // Select Vref=Vcc REFS=[000]

  ADCSRA = (0 << ADPS0) | // Prescaler 16 ADPS=[100]
           (0 << ADPS1) | //
           (1 << ADPS2) | //
           (0 << ADIE ) | // No ADC interrupts
           (0 << ADIF ) | //
           (1 << ADATE) | // Enable Auto Trigger
           (1 << ADSC ) | // Start conversion
           (1 << ADEN );  // Enable ADC

  ADCSRB = (0 << ADTS0) | // Free running mode ADTS=[000]
           (0 << ADTS1) | //
           (0 << ADTS2) | //
           (0 << IPR  ) | //
           (0 << ACME ) | //
           (0 << BIN  );  //
}

void timer_setup()
{
  TCCR0A=0x00;                     // normal mode
  TCCR0B=0x00;
  TCCR0B |= (1<<CS00) | (1<<CS01); // prescaling with 64
  TCNT0=0;
  TIMSK|=(1<<TOIE0);               // enabling timer0 interrupt
  PORTB|=(1<<PB1);
}

void loop() {
   go_sleep();
}

// override Arduino's main function to be able to install custom timer0 interrupt
int main() {
  setup();
  while (true) loop();
}

inline void go_sleep() {
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_enable();
  sleep_mode();
  sleep_disable();
}

// /OE received from console, shift one bit
ISR(INT0_vect)
{
    if (Shift_Register & (1 << MSBIT)) {
      pinMode(DIGI_OUT_P0, INPUT_PULLUP);
    } else {
      digitalWrite(DIGI_OUT_P0, LOW);
      pinMode(DIGI_OUT_P0, OUTPUT);
    }
    Shift_Register <<= 1;
    GIFR |= (1 << PCIF);
}

// Start_ADC received from console, wait 3ms and continue in timer0 interrupt handler
// to prevent updating knob position prematurely before console finishes reading previous data
// from shift register
ISR(PCINT0_vect)
{
      Timer_Count = 0;
}

// Interrupt vector for Timer0
// whole operation (including ADC reading) should take around 7 ms
ISR (TIMER0_OVF_vect)
{
  if (Timer_Count>0) // waiting for 3ms
  {
    if (Timer_Count == 1) {
      while (!(ADCSRA & (1 << ADIF)) );
      Knob_Raw_Input = ADC ^ 0x3FF;      // depending on how you wire your potentiometer
      // Knob_Raw_Input = ADC            // you may or may not want to flip bits coming from ADC
                                         // to adjust paddle direction
      ADCSRA |= (1 << ADIF);

#ifdef USE_LUT
      Shift_Register = pgm_read_word(Knob_Map + Knob_Raw_Input) >> 1;
#else
      Shift_Register = Knob_Raw_Input >> 1;
#endif

      if (Shift_Register & (1 << MSBIT)) {
        pinMode(DIGI_OUT_P0, INPUT_PULLUP);
      } else {
        digitalWrite(DIGI_OUT_P0, LOW);
        pinMode(DIGI_OUT_P0, OUTPUT);
      }
      Shift_Register <<= 1;
      Timer_Count++;
    }
  }
  else  Timer_Count++;
}
