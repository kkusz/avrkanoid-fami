/**************************************************************************************
            ___  _   _______ _                     _     _       ______              _ 
           / _ \| | | | ___ \ |                   (_)   | |      |  ___|            (_)
          / /_\ \ | | | |_/ / | ____ _ _ __   ___  _  __| |______| |_ __ _ _ __ ___  _ 
          |  _  | | | |    /| |/ / _` | '_ \ / _ \| |/ _` |______|  _/ _` | '_ ` _ \| |
          | | | \ \_/ / |\ \|   < (_| | | | | (_) | | (_| |      | || (_| | | | | | | |
          \_| |_/\___/\_| \_|_|\_\__,_|_| |_|\___/|_|\__,_|      \_| \__,_|_| |_| |_|_|
                                                                                                                                              
          DIY Arkanoid "Vaus" paddle clone for Famicom and compatibles
          based on Digispark ATtiny85 development board
          KKusz 2024 https://kusz.me https://github.com/kkusz/avrkanoid-fami

          Original work by Danjovic 2020
          https://github.com/Danjovic/MSX/blob/master/DigiArka

**************************************************************************************/

#include <avr/sleep.h>
#include <avr/interrupt.h>
#include <avr/power.h>
#include <avr/pgmspace.h>

// Lookup table for non-linearity compensation of "linear" potentiometer
const uint16_t Knob_Map[1024] PROGMEM = {
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376,
    376, 376, 376, 381, 389, 397, 405, 413, 421, 429, 437, 445, 453, 461, 468, 475, 483,
    490, 497, 505, 512, 519, 527, 534, 541, 549, 556, 563, 571, 578, 585, 593, 600, 607,
    615, 621, 627, 633, 638, 644, 650, 655, 661, 667, 672, 678, 684, 690, 695, 701, 707,
    712, 718, 724, 729, 735, 741, 746, 752, 758, 764, 769, 775, 781, 786, 792, 798, 803,
    809, 812, 814, 815, 817, 818, 819, 821, 822, 824, 825, 827, 828, 829, 831, 832, 834,
    835, 837, 838, 839, 841, 842, 844, 845, 847, 848, 849, 851, 852, 854, 855, 856, 858,
    859, 861, 862, 864, 865, 866, 868, 869, 871, 872, 874, 875, 876, 878, 879, 881, 882,
    884, 885, 886, 888, 889, 891, 892, 894, 895, 896, 898, 899, 901, 902, 903, 905, 906,
    908, 909, 909, 910, 910, 910, 911, 911, 912, 912, 913, 913, 914, 914, 914, 915, 915,
    916, 916, 917, 917, 918, 918, 918, 919, 919, 920, 920, 921, 921, 922, 922, 923, 923,
    923, 924, 924, 925, 925, 926, 926, 927, 927, 927, 928, 928, 929, 929, 930, 930, 931,
    931, 931, 932, 932, 933, 933, 934, 934, 935, 935, 935, 936, 936, 937, 937, 938, 938,
    939, 939, 939, 940, 940, 941, 941, 942, 942, 943, 943, 943, 944, 944, 945, 945, 946,
    946, 947, 947, 947, 948, 948, 949, 949, 950, 950, 950, 951, 951, 951, 952, 952, 952,
    952, 953, 953, 953, 953, 953, 954, 954, 954, 954, 955, 955, 955, 955, 956, 956, 956,
    956, 957, 957, 957, 957, 958, 958, 958, 958, 959, 959, 959, 959, 960, 960, 960, 960,
    961, 961, 961, 961, 962, 962, 962, 962, 963, 963, 963, 963, 964, 964, 964, 964, 965,
    965, 965, 965, 966, 966, 966, 966, 966, 967, 967, 967, 967, 968, 968, 968, 968, 969,
    969, 969, 969, 970, 970, 970, 970, 971, 971, 971, 971, 972, 972, 972, 972, 973, 973,
    973, 973, 973, 974, 974, 974, 974, 974, 974, 975, 975, 975, 975, 975, 975, 975, 976,
    976, 976, 976, 976, 976, 977, 977, 977, 977, 977, 977, 977, 978, 978, 978, 978, 978,
    978, 979, 979, 979, 979, 979, 979, 980, 980, 980, 980, 980, 980, 980, 981, 981, 981,
    981, 981, 981, 982, 982, 982, 982, 982, 982, 982, 983, 983, 983, 983, 983, 983, 984,
    984, 984, 984, 984, 984, 985, 985, 985, 985, 985, 985, 985, 986, 986, 986, 986, 986,
    986, 987, 987, 987, 987, 987, 987, 988, 988, 988, 988, 988, 988, 988, 989, 989, 989,
    989, 989, 989, 990, 990, 990, 990, 990, 990, 990, 991, 991, 991, 991, 991, 991, 992,
    992, 992, 992, 992, 992, 993, 993, 993, 993, 993, 993, 993, 994, 994, 994, 994, 994,
    994, 995, 995, 995, 995, 995, 995, 995, 996, 996, 996, 996, 996, 996, 997, 997, 997,
    997, 997, 997, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 1000,
    1000, 1000, 1000, 1000, 1000, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1002, 1002,
    1002, 1002, 1002, 1002, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1004, 1004, 1004,
    1004, 1004, 1004, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1006, 1006, 1006, 1006,
    1006, 1006, 1006, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1008, 1008, 1008,
    1008, 1008, 1008, 1008, 1008, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1010,
    1010, 1010, 1010, 1010, 1010, 1010, 1010, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 
    011, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1013, 1013, 1013, 1013, 1013,
    1013, 1013, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 1015, 1015, 1015, 1015,
    1015, 1015, 1015, 1016, 1016, 1016, 1016, 1016, 1017, 1017, 1017, 1017, 1017, 1018,
    1018, 1018, 1018, 1018, 1018, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1020,
    1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1021, 1021, 1021, 1022, 1022, 1022,
    1023, 1023, 1023
};

// output serial knob data
#define DIGI_OUT_P0 0

// input start ADC
#define DIGI_IN_P1  1

// input read knob data
#define DIGI_IN_P2  2

#define MSBIT 8

volatile uint8_t Input_ADC;
volatile uint16_t Knob_Raw_Input;
volatile uint16_t Shift_Register;
volatile uint8_t Timer_Count = 0;

void setup() {
  init_adc();
  timer_setup();

  cli();

  GIMSK |= (1 << INT0) |
           (1 << PCIE);
  MCUCR =  (0 << ISC00) | // External INT on Falling edge ISC=[10])
           (1 << ISC01); // on pin TRGA (clock). Don't care for Standard
  PCMSK = (0 << PCINT0) | //
          (1 << PCINT1) | // Pin change INT on PULSE pin
          (0 << PCINT2) | //
          (0 << PCINT3) | //
          (0 << PCINT4) | //
          (0 << PCINT5); //

  // clear any pending interrupts
  GIFR =  (1 << INTF0) |
          (1 << PCIF );

  analogReference(DEFAULT);
  pinMode(DIGI_IN_P1,  INPUT_PULLUP);
  pinMode(DIGI_IN_P2,  INPUT_PULLUP);
  pinMode(DIGI_OUT_P0, OUTPUT);

  sei();
}

void init_adc() {

  ADMUX  = (1 << MUX0 ) | // Select AN3 ADMUX=[0011]
           (1 << MUX1 ) | //
           (0 << MUX2 ) | //
           (0 << MUX3 ) | //
           (0 << REFS2) | //
           (0 << ADLAR) | // Right Aligned value 
           (0 << REFS0) | //
           (0 << REFS1);  // Select Vref=Vcc REFS=[000]

  ADCSRA = (0 << ADPS0) | // Prescaler 16 ADPS=[100]
           (0 << ADPS1) | //
           (1 << ADPS2) | //
           (0 << ADIE ) | // No ADC interrupts
           (0 << ADIF ) | //
           (1 << ADATE) | // Enable Auto Trigger
           (1 << ADSC ) | // Start conversion
           (1 << ADEN );  // Enable ADC

  ADCSRB = (0 << ADTS0) | // Free running mode ADTS=[000]
           (0 << ADTS1) | //
           (0 << ADTS2) | //
           (0 << IPR  ) | //
           (0 << ACME ) | //
           (0 << BIN  );  //
}

void timer_setup()
{
  TCCR0A=0x00;                     // normal mode
  TCCR0B=0x00;
  TCCR0B |= (1<<CS00) | (1<<CS01); // prescaling with 64
  TCNT0=0;
  TIMSK|=(1<<TOIE0);               // enabling timer0 interrupt
  PORTB|=(1<<PB1);
}

void loop() {
   go_sleep();
}

// override Arduino's main function to be able to install custom timer0 interrupt
int main() {
  setup();
  while (true) loop();
}

inline void go_sleep() {
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_enable();
  sleep_mode();
  sleep_disable();
}

// /OE received from console, shift one bit
ISR(INT0_vect)
{
    if (Shift_Register & (1 << MSBIT)) {
      pinMode(DIGI_OUT_P0, INPUT_PULLUP);
    } else {
      digitalWrite(DIGI_OUT_P0, LOW);
      pinMode(DIGI_OUT_P0, OUTPUT);
    }
    Shift_Register <<= 1;
    GIFR |= (1 << PCIF);
}

// Start_ADC received from console, wait 3ms and continue in timer0 interrupt handler
// to prevent updating knob position prematurely before console finishes reading previous data
// from shift register
ISR(PCINT0_vect)
{
      Timer_Count = 0;
}

// Interrupt vector for Timer0
// whole operation (including ADC reading) should take around 7 ms
ISR (TIMER0_OVF_vect)
{
  if (Timer_Count>0) // waiting for 3ms
  {
    if (Timer_Count == 1) {
      while (!(ADCSRA & (1 << ADIF)) );
      Knob_Raw_Input = ADC ^ 0x3FF;      // depending on how you wire your potentiometer
      // Knob_Raw_Input = ADC            // you may or may not want to flip bits coming from ADC
      ADCSRA |= (1 << ADIF);

      //Shift_Register = pgm_read_word(Knob_Map + Knob_Raw_Input) >> 1; // uncomment to use LUT non-linearity compensation
                                                                        // (mileage may vary)
      Shift_Register = Knob_Raw_Input >> 1;                             // keep it like that if your potentiometer is linear enough

      if (Shift_Register & (1 << MSBIT)) {
        pinMode(DIGI_OUT_P0, INPUT_PULLUP);
      } else {
        digitalWrite(DIGI_OUT_P0, LOW);
        pinMode(DIGI_OUT_P0, OUTPUT);
      }
      Shift_Register <<= 1;
      Timer_Count++;
    }
  }
  else  Timer_Count++;
}
